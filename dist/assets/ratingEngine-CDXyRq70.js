import{s as y}from"./index-hdINvOfJ.js";function M(s,e,d){const{p1:i,p2:c}=s,{p3:r,p4:p}=e,u=(i.rating+c.rating)/2,f=(r.rating+p.rating)/2;if(Math.abs(u-f)>1)return{skipped:!0,message:"Disparidade demasiado alta (>"+Math.abs(u-f).toFixed(2)+"), nível inalterado"};const m=1/(1+Math.pow(10,(f-u)/2)),g=d.sets1>d.sets2?1:d.sets1<d.sets2?0:.5;let n=1;const F=Math.abs(d.gamesTotal1-d.gamesTotal2);d.sets1+d.sets2===3?n=.6:F>8&&(n=1.3);const R=t=>t<10?.15:t<50?.08:.04,_=(t,o,a,l)=>{const w=R(t.matches)*(o-a)*l;return parseFloat(w.toFixed(4))},$=_(i,g,m,n),v=_(c,g,m,n),E=_(r,1-g,1-m,n),b=_(p,1-g,1-m,n),h=t=>Math.max(.5,Math.min(7,parseFloat(t.toFixed(2))));return{team1:{p1:{...i,rating:h(i.rating+$),delta:$,matches:i.matches+1},p2:{...c,rating:h(c.rating+v),delta:v,matches:c.matches+1}},team2:{p3:{...r,rating:h(r.rating+E),delta:E,matches:r.matches+1},p4:{...p,rating:h(p.rating+b),delta:b,matches:p.matches+1}}}}function k(s){return s<=0?0:s>=50?100:Math.min(100,Math.round(100*(1-Math.exp(-s/15))))}async function q(s){const{data:e,error:d}=await y.from("matches").select(`
      id, team1_id, team2_id, status,
      team1_score_set1, team2_score_set1,
      team1_score_set2, team2_score_set2,
      team1_score_set3, team2_score_set3,
      player1_individual_id, player2_individual_id,
      player3_individual_id, player4_individual_id
    `).eq("id",s).single();if(d||!e)return console.error("[RatingEngine] Match not found:",s,d),null;if(e.status!=="completed")return console.log("[RatingEngine] Match not completed, skipping:",s),null;const i=[e.team1_score_set1??0,e.team2_score_set1??0],c=[e.team1_score_set2??0,e.team2_score_set2??0],r=[e.team1_score_set3??0,e.team2_score_set3??0],p=(i[0]>i[1]?1:0)+(c[0]>c[1]?1:0)+(r[0]>r[1]?1:0),u=(i[1]>i[0]?1:0)+(c[1]>c[0]?1:0)+(r[1]>r[0]?1:0),f=i[0]+c[0]+r[0],m=i[1]+c[1]+r[1];if(p===0&&u===0)return console.log("[RatingEngine] No sets played, skipping:",s),null;const g={sets1:p,sets2:u,gamesTotal1:f,gamesTotal2:m};let n=[];if(e.player1_individual_id||e.player2_individual_id)n=[e.player1_individual_id,e.player2_individual_id,e.player3_individual_id,e.player4_individual_id].filter(Boolean);else if(e.team1_id&&e.team2_id){const{data:o}=await y.from("teams").select("id, player1_id, player2_id").in("id",[e.team1_id,e.team2_id]);if(!o||o.length<2)return console.error("[RatingEngine] Could not find teams for match:",s),null;const a=o.find(x=>x.id===e.team1_id),l=o.find(x=>x.id===e.team2_id);n=[a==null?void 0:a.player1_id,a==null?void 0:a.player2_id,l==null?void 0:l.player1_id,l==null?void 0:l.player2_id].filter(Boolean)}if(n.length<4)return console.log("[RatingEngine] Less than 4 players found, skipping:",s,"found:",n.length),null;const{data:R}=await y.from("players").select("id, name, phone_number, user_id").in("id",n);if(!R||R.length<4)return console.log("[RatingEngine] Could not fetch all player entries:",s),null;const _=new Map;for(const o of R){let a=null;if(o.user_id){const{data:l}=await y.from("player_accounts").select("id, user_id, name, level, wins, losses, level_reliability_percent").eq("user_id",o.user_id).maybeSingle();l&&(a=l)}if(!a&&o.phone_number){const{data:l}=await y.from("player_accounts").select("id, user_id, name, level, wins, losses, level_reliability_percent").eq("phone_number",o.phone_number).maybeSingle();l&&(a=l)}if(!a&&o.name){const{data:l}=await y.from("player_accounts").select("id, user_id, name, level, wins, losses, level_reliability_percent").ilike("name",o.name).maybeSingle();l&&(a=l)}a&&_.set(o.id,a)}if(_.size<4)return console.log("[RatingEngine] Could not map all players to accounts:",s,"mapped:",_.size),null;const $=o=>{const a=_.get(o);return a?{id:a.id,user_id:a.user_id||"",name:a.name||"",rating:a.level??3,matches:(a.wins??0)+(a.losses??0)}:null},v=$(n[0]),E=$(n[1]),b=$(n[2]),h=$(n[3]);if(!v||!E||!b||!h)return console.log("[RatingEngine] Could not build all player ratings"),null;const t=M({p1:v,p2:E},{p3:b,p4:h},g);if(t.skipped)return console.log("[RatingEngine] Match skipped:",t.message),t;if(t.team1&&t.team2){const o=[t.team1.p1,t.team1.p2,t.team2.p3,t.team2.p4];for(const a of o){const{error:l}=await y.from("player_accounts").update({level:a.rating,level_reliability_percent:k(a.matches)}).eq("id",a.id);l&&console.error("[RatingEngine] Error updating player:",a.id,l)}console.log("[RatingEngine] Updated ratings for match:",s),console.log(`  ${t.team1.p1.name}: ${v.rating.toFixed(2)} → ${t.team1.p1.rating.toFixed(2)} (${t.team1.p1.delta>0?"+":""}${t.team1.p1.delta.toFixed(4)})`),console.log(`  ${t.team1.p2.name}: ${E.rating.toFixed(2)} → ${t.team1.p2.rating.toFixed(2)} (${t.team1.p2.delta>0?"+":""}${t.team1.p2.delta.toFixed(4)})`),console.log(`  ${t.team2.p3.name}: ${b.rating.toFixed(2)} → ${t.team2.p3.rating.toFixed(2)} (${t.team2.p3.delta>0?"+":""}${t.team2.p3.delta.toFixed(4)})`),console.log(`  ${t.team2.p4.name}: ${h.rating.toFixed(2)} → ${t.team2.p4.rating.toFixed(2)} (${t.team2.p4.delta>0?"+":""}${t.team2.p4.delta.toFixed(4)})`)}return t}async function D(s,e){let d=y.from("matches").select("id, scheduled_time, tournament_id").eq("status","completed").order("scheduled_time",{ascending:!0});s&&(d=d.gte("scheduled_time",s));const{data:i,error:c}=await d;if(c)return console.error("[RatingEngine] Error fetching matches:",c),{processed:0,skipped:0,errors:1,total:0};if(!i||i.length===0)return console.log("[RatingEngine] No matches to process"),{processed:0,skipped:0,errors:0,total:0};console.log(`[RatingEngine] Found ${i.length} completed matches to process`),e==null||e(0,i.length,"A iniciar processamento...");let r=0,p=0,u=0;for(let m=0;m<i.length;m++){const g=i[m];try{const n=await q(g.id);n?n.skipped?p++:r++:u++}catch(n){console.error("[RatingEngine] Error processing match:",g.id,n),u++}((m+1)%5===0||m===i.length-1)&&(e==null||e(m+1,i.length,`Processados: ${r} | Saltados: ${p} | Erros: ${u}`))}const f=`[RatingEngine] CONCLUÍDO: ${r} processados, ${p} saltados, ${u} erros de ${i.length} total`;return console.log(f),e==null||e(i.length,i.length,f),{processed:r,skipped:p,errors:u,total:i.length}}export{M as calculateNewRatings,k as calculateReliability,D as processAllUnratedMatches,q as processMatchRating};
